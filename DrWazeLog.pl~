% Hecho       : rutaCorta
% Descripción : Es un hecho dinámico usado para guardar las rutas con
%                  menos costo entre los nodos del grafo

:- dynamic
	rutaCorta/2.

% Regla       : verRutasCortas
% Entradas    : RutaCorta -> Lista de la ruta con nodos del grafo
%               Costo -> Sumatoria de los costos de la ruta
% Descripción : Tendrá éxito si la ruta dada junto a su costo es
%                  un hecho en la base de datos dinámica

verRutasCortas(RutaCorta,Costo):-
	rutaCorta(RutaCorta,Costo).

% Hecho       : ruta
% Descripción : Representa todas las direcciones (arcos) disponibles
%                  entre los lugares del mapa y su respectivo costo.

ruta("cartago", "paraiso", 10).
ruta("cartago", "pacayas", 13).
ruta("cartago", "tres_rios", 8).
ruta("cartago", "san_jose", 20).
ruta("cartago", "musgo_verde", 10).
ruta("pacayas", "cervantes", 8).
ruta("pacayas", "cartago", 13).
ruta("pacayas", "tres_rios", 15).
ruta("cervantes", "juan_vinas", 5).
ruta("cervantes", "cachi", 7).
ruta("cervantes", "pacayas", 8).
ruta("turrialba", "pacayas", 18).
ruta("juan_vinas", "turrialba", 4).
ruta("paraiso", "cervantes", 4).
ruta("paraiso", "cachi", 10).
ruta("paraiso", "orosi", 8).
ruta("san_jose", "corralillo", 22).
ruta("san_jose", "cartago", 20).
ruta("tres_rios", "san_jose", 8).
ruta("musgo_verde", "cartago", 10).
ruta("musgo_verde", "corralillo", 6).
ruta("corralillo", "musgo_verde", 6).
ruta("corralillo", "san_jose", 22).
ruta("orosi", "paraiso", 8).
ruta("orosi", "cachi", 12).
ruta("cachi", "turrialba", 40).
ruta("cachi", "cervantes", 7).
ruta("cachi", "paraiso", 10).
ruta("cachi", "orosi", 12).

% Regla       : viajar

% Entradas    : Inicio -> Punto de inicio en el mapa
%               Final -> Punto de llegada en el mapa
%               Ruta -> Ruta recorrida desde el inicio al final
%               CostoSumado -> Costo total de la ruta recorrida
% Descripción : Tendrá éxito si encuentra alguna ruta entre el punto
%		   inicial y el final

viajar(Inicio, Final, Ruta, CostoSumado):-
	recorrer(Inicio),
	rutaCorta(Ruta, Costo),
	inversa(Ruta,[Final|_]),
	CostoSumado is round(Costo).

% Entradas    : Cuatro argumentos cualquiera
% Descripción : Tendrá éxito siempre, y se ejecuta cuando no se
%                  encuentra una ruta entre dos puntos del mapa.

viajar(_, _, _, _):- !, fail.

% Entradas    : Inicio -> Punto de inicio en el mapa
%               Final -> Punto de llegada en el mapa
%               RutaTotal -> Ruta recorrida con anterioridad
%               CostoTotal -> Costo de la ruta recorrida
% Descripción : Tendrá éxito si existe una ruta entre el nodo inicial y
%	           el nodo final, pero solo si no se solicitan nodos
%	           intermedios.

viajar(Inicio, [], Final, [], 0, RutaTotal, CostoTotal):-
	!, viajar(Inicio, Final, RutaTotal, CostoEncontrado),
	CostoTotal is round(CostoEncontrado).

% Entradas    : Inicio -> Punto de inicio en el mapa
%               Final -> Punto de llegada en el mapa
%               RutaEncontrada -> Ultima ruta recorrida
%               CostoEncontrado -> Costo de la ultima ruta recorrida
% Descripción : Condición de parada para viajar. Analiza la última ruta
%		   para completar la ruta total más corta posible entre
%		   los puntos inicio y final definidos al inicio de la
%		   recursión. Si existe una ruta, la imprime en la
%		   consola.

viajar(Inicio, [], Final, _, _, RutaEncontrada, CostoEncontrado):-
	!, viajar(Inicio, Final, [_|RutaEncontrada], CostoEncontrado), !.

% Entradas    : Inicio -> Punto de inicio en el mapa
%               Siguiente -> Primer punto intermedio en el viaje
%               Demas -> Resto de puntos intermedios en el viaje
%               Final -> Punto de llegada en el mapa
%               RutaTotal -> Camino que falta por recorrer
%               CostoTotal -> Costo de las futuras rutas
% Descripción : Inicio de la recursión para determinar la ruta
%		   total. Tiene éxito si encuentra una ruta entre el
%		   punto de inicio y el final pasando por todos los
%		   puntos intermedios.

viajar(Inicio, [Siguiente|Demas], Final, [], 0, RutaTotal, CostoTotal):-
	!, viajar(Inicio, Siguiente, RutaEncontrada, CostoEncontrado), !,
	concatenar(RutaEncontrada, SiguienteRuta, RutaTotal),
	viajar(Siguiente, Demas, Final, RutaEncontrada, round(CostoEncontrado), SiguienteRuta, CostoSiguiente),
	CostoTotal is round(CostoEncontrado + CostoSiguiente).

% Entradas    : Inicio -> Punto de inicio en el mapa
%               Siguiente -> Primer punto intermedio en el viaje
%               Demas -> Resto de puntos intermedios en el viaje
%               Final -> Punto de llegada en el mapa
%               Ruta -> Ruta recorrida con anterioridad
%               Costo -> Costo de la ruta recorrida
%               RutaFutura -> Camino que falta por recorrer
%               CostoFuturo -> Costo de las futuras rutas
% Descripción : Tendrá éxito si encuentra rutas entre el punto de inicio
%	           y el primer punto intermedio, y este con el siguiente
%	           punto intermedio, etc; y si existe una ruta entre el
%	           último punto intermedio y el punto de llegada.

viajar(Inicio, [Siguiente|Demas], Final, Ruta, Costo, RutaFutura, CostoFuturo):-
	!, viajar(Inicio, Siguiente, [_|RutaEncontrada], CostoEncontrado), !,
	concatenar(Ruta, RutaEncontrada, RutaTotal),
	concatenar(RutaEncontrada, RutaSiguiente, RutaFutura),
	viajar(Siguiente, Demas, Final, RutaTotal, round(CostoEncontrado + Costo), RutaSiguiente, CostoSiguiente),
	CostoFuturo is round(CostoEncontrado + CostoSiguiente).

% Regla       : respuestaWazeLog

% Entradas    : Inicio -> Punto de inicio en el mapa
%               Final -> Punto de llegada en el mapa
%               Ruta -> Ruta recorrida con anterioridad
%               Costo -> Costo de la ruta recorrida
% Descripción : Imprime en consola la ruta requerida para realizar el
%                  recorrido deseado por el cliente, además de su costo
%		   correspondiente.

respuestaWazeLog(Inicio, Final, Ruta, Costo):-
	write('La mejor ruta para ir desde '),
	write(Inicio),
	write(' hasta '),
	write(Final),
	write(' es '),
	escribirRuta(Ruta),
	write(', con un costo de '),
	write(Costo),
	write(' horas.\n').

respuestaWazeLog(Inicio, Final, _, _):-
	write('No hay rutas para ir desde '),
	write(Inicio),
	write(' hasta '),
        write(Final),
	write(' .\n').

% Regla       : concatenar

% Entradas    : Lista -> lista de elementos
% Descripción : Tendrá éxito si la primer lista es vacía y las otras dos
%                  listas son iguales

concatenar([],Lista,Lista).

% Entradas    : Elemento -> Primer elemento de las listas 1 y 3
%		Resto1, Resto3 -> Colas de las listas 1 y 3
%		Lista2 -> Lista de elementos
% Descripción : Analiza 'concatenar' para la cola de la lista 1, la
%		   lista 2 y la cola de la lista 3 si el primer elemento
%		   de la lista 1 y 3 son iguales

concatenar([Elemento|Resto1],Lista2,[Elemento|Resto3]):- concatenar(Resto1,Lista2,Resto3).

% Regla       : recorrer

% Entradas    : Inicio -> Punto actual en el mapa
%               Ruta -> Camino seguido hasta el punto actual en el mapa
%               Costo -> Costo de la ruta actual analizada
% Descripción : Tendrá éxito y procederá a buscar las rutas más cortas
%		   próximas al punto actual si existe algún punto
%		   vecino al punto actual que no sea miembro de la ruta
%		   ya analizada

recorrer(Inicio, Ruta, Costo):-
	ruta(Inicio, RutaEncontrada, CostoEncontrada),
	not(miembro(RutaEncontrada, Ruta)),
	rutaMasCorta([RutaEncontrada, Inicio|Ruta], Costo + CostoEncontrada),
	recorrer(RutaEncontrada, [Inicio|Ruta], Costo + CostoEncontrada).

% Entradas    : Inicio -> Punto de inicio en el mapa
% Descripción : Limpia la base de datos e inicia el recorrido del mapa
%                  para encontrar las nuevas rutas más cortas

recorrer(Inicio):-
	retractall(rutaCorta(_, _)),
	recorrer(Inicio, [], 0).

% Entradas    : Un elemento cualquiera (punto inicial por defecto)
% Descripción : Punto de parada para el recorrido y el backtracking del
%                  mapa en busca de las rutas más cortas

recorrer(_).

% Regla       : miembro

% Entradas    : Inicio -> Elemento cualquiera que representa el primer
%	           argumento y la cabeza de la lista en el segundo
%	           argumento.
% Descripción : Tendrá éxito si la cabeza de la
%	           lista y el elemento solicitado son iguales


miembro(Elemento, [Elemento|_]).

% Entradas    : Elemento -> Elemento a encontrar en la lista
%		Cola -> Cola de la lista en la que se quiere buscar el
%		   elemento
% Descripción : Vuelve a llamar a la regla miembro con la cola de la
%		   lista como la nueva lista, hasta que esta sea nula o
%		   su cabeza sea el elemento que se busca

miembro(Elemento, [_|Cola]):- miembro(Elemento, Cola).

% Regla       : rutaMasCorta

% Entradas    : Primera -> Nodo del grafo al que va a buscar una ruta más
%		   corta de la existente
%		Ruta -> Camino seguido hasta el nodo actual que se está
%		   actualizando
% Descripción : Si existe alguna ruta hasta el nodo actual en la base
%		   de datos, se sobreescribe por esta nueva ruta si el
%		   costo de la ruta actual es menor a la de la ruta
%		   guardada

rutaMasCorta([Primer|Ruta], Costo):-
	rutaCorta(RutaCortaEncontrada, CostoEncontrado),
	inversa(RutaCortaEncontrada, [Primer|_]), !,
	Costo < CostoEncontrado,
        retract(rutaCorta(RutaCortaEncontrada, _)),
	inversa([Primer|Ruta], NuevaRutaCorta),
	assert(rutaCorta(NuevaRutaCorta, Costo)).

% Entradas    : Ruta -> Ruta seguida hasta llegar al nodo actual
%               Costo -> Costo total de la ruta correspondiente
% Descripción : Añade la actual ruta a la base de datos dinámicas de las
%                  rutas más cortas

rutaMasCorta(Ruta, Costo):-
	inversa(Ruta,RutaCorta),
	assert(rutaCorta(RutaCorta,Costo)).

% Regla       : inversa

% Entradas    : Lista1, Lista2 -> Listas que son inversas la una con la
%                  otra
% Descripción : Inicia el análisis para verificar si las listas son
%                  inversas

inversa(Lista1, Lista2):- inversa(Lista1, [], Lista2).

% Entradas    : Lista -> Lista de elementos
% Descripción : Condición de parada para la regla 'inversa'. Tendrá
%		   éxito cuando la lista en el segundo y tercer
%		   parámetro sean iguales y la primer lista sea vacía

inversa([], Lista, Lista).

% Entradas    : Primer1 -> Cabeza de la primer lista
%               Cola1 -> Cola de la primer lista
%               Lista2 -> Segunda lista
%               Lista3 -> Tercer lista
% Descripción : Verifica la regla 'inversa' usando de primer lista la
%		   primer cola original; de segunda la concatenación de
%		   la primer cabeza y la segunda lista original; y como
%		   la tercer lista la tercer lista original.

inversa([Primer1|Cola1], Lista2, Lista3):- inversa(Cola1, [Primer1|Lista2], Lista3).

% Regla       : escribirRuta
% Entradas    : Primer -> Punto de partida de la ruta actual
%               Ruta -> Ruta que se debe seguir para llegar al destino
% Descripción : Inicia la impresión de la ruta con el primer nodo

escribirRuta([Primer|Ruta]):-
	write(Primer),
	escribirRutaAux(Ruta).

% Regla       : escribirRutaAux

% Entradas    : Su argumento debe ser una lista vacía
% Descripción : Finaliza la impresión de una ruta. Condición de parada
%                  para 'escribirRuta'

escribirRutaAux([]):- write('').

% Entradas    : Siguiente -> Nodo siguiente al último nodo impreso en
%                  consola
%		Ruta -> Resto de la ruta que hace falta imprimir
% Descripción : Imprime los demás elementos de una ruta mediante
%		   recursión despuésde haber impreso el punto de partida
%		   ('escrbirRuta')

escribirRutaAux([Siguiente|Ruta]):-
	write(' -> '),
	write(Siguiente),
	escribirRutaAux(Ruta).

